<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Примеры использования программы VPSYS</title>
<style type="text/css">
  TD, TH {
    text-align: left;
    padding: 2px;
  }
  TH {
    color: blue;
  }
  .even {
    color: gray;
  }
  .lc {
    color: blue;
  }
</style>


</head>
<body>

<h4>Содержание<h4>
<ul>
<li><a href="#samp1">Пример 1. "Hello, World"</a></li>
<li><a href="#samp2">Пример 2. "Hello, World" в интерпретаторе</a></li>
<li><a href="#samp3">Пример 3. Калькулятор</a></li>
<li><a href="#samp4">Пример 4. Переменные, константы, ссылки</a></li>
<li><a href="#samp5">Пример 5. Массивы и строки</a></li>
<li><a href="#samp6">Пример 6. Первая схема</a></li>
<li><a href="#samp7">Пример 7. Вторая схема</a></li>
<li><a href="#samp8">Пример 8. Свёртки</a></li>
<li><a href="#samp9">Пример 9. Графы и блоки</a></li>
<li><a href="#samp10">Пример 10. Дифференциальное уравнение</a></li>
<li><a href="#samp11">Пример 11. Создание нового типа</a></li>
</ul>

<h3>ЗНАКОМСТВО С ПРОГРАММОЙ</h3>

<a name="samp1"></a>
<h4>Пример 1. "Hello, World"</h4>

<p>Начнём с традиционно с вывода текстового сообщения. Откройте текстовый
редактор типа "блокнот", напишите в нём строку

<code>
<table>
<tr>
  <th>"Hello, World!"</th>
  <th class="even"># вывод строки</th>
</tr>
</table>
</code>

Сохраните файл, например как hello.vps (расширение файла роли не играет),
затем через консоль запустите VPSYS, передав в виде аргумента название
файла. Для этого откройте терминал (консоль), перейдите в папку с программой и
выполните команду:<br>
<code>vpsys.exe hello.vps</code><br>
В Linux нужно будет написать <br>
<code>./vpsys.exe hello.vps</code><br>
Программа выведет содержимое текстовой строки и завершит работу. Здесь
предполагается, что файл hello.vps лежит в той же директории, что и vpsys.exe,
если это не так, либо переместите файл в папку программы, либо укажите полный
путь.
</p>

<p> В данном примере использовался режим исполнения. Если вы написали
скрипт, который в дальнейшем будет использоваться без значительных
модификаций, запускайте его в данном режиме. Для разработки же удобнее
использоваться режим интерпретации, чтобы его запустить, просто откройте
VPSYS без дополнительных аргументов командной строки. Дальнейшие примеры, если
специально не оговорено, будут рассмотрены в режиме интерпретации.
</p>

<a name="samp2"></a>
<h4>Пример 2. "Hello, World" в интерпретаторе</h4>

<p>Откройте папку с программой и запустите VPSYS (в Windows - двойным щелчком
по vpsys.exe, в Linux - через команду "./vpsys"). В результате должно появиться
приветствие и приглашение к вводу ">>". Выход из программы возможен по команде
<b>end</b> либо при 3-кратном последовательном вводе пустой строки.
</p>

<p>Выполнить файл со скриптом можно и из режима интерпретатора. Для этого
нужно его загрузить с помощью команды <b>load</b>:

<code>
<table>
<tr>
  <th>Load "hello.vps"</th>
  <th class="even"># исполнение файла "hello.vps"</th>
</tr>
</table>
</code>
VPSYS не чувствителен к регистру, по-этому load, Load или LOAD означает
одно и то же. Данное правило не распространяется только на строки, т.е.
последовательности символов, заключённые в двойные кавычки. Знак '#' служит
для выделения строчных комментариев. Комментарии не участвуют в выполнении и
используются для пояснения содержания либо при отладке. Строки же участвуют в
расчёте, по-этому могут играть роль комментариев в исполняемых скриптах.
</p>

<p>Загруку скрипта можно также производить построчно. Для этого случит команда
<b>load dbg</b>:

<code>
<table>
<tr>
  <th>Load dbg "hello.vps"</th>
  <th class="even"># построчное исполнение файла "hello.vps"</th>
</tr>
</table>
</code>
После каждой строки будет выводиться вопрос об исполнении, если ввести
'n', она будет пропущена, иначе выполнена. Данный режим может быть полезен
при отладке больших скриптов.
</p>

<p>Естественно, режим интерпретатора преднозначен, прежде всего, для
написания и построчного исполнения скриптов, по-этому вы можете ввести

<code>
<table>
<tr>
  <th>"Hello, World!"</th>
</tr>
</table>
</code>

и получить тот же эффект, т.е. строка будет записана в качестве результата.
</p>

<a name="samp3"></a>
<h4>Пример 3. Калькулятор</h4>

<p>Числа в VPSYS могут быть целыми, с плавающей запятой или комплексными. При
этом преобразования типов выполняются динамически в ходе расчётов. Основной
формат ввода - десятичный, однако, целые числа могут быть записаны в двоичном
(0b...) или 16-ричном (0x...) представлении. Например, запись
<code>
<table>
<tr>
  <th>0b10 + 0xFF + 3</th>
</tr>
</table>
</code>
вернёт результат 260 (результат всегда представлен в десятичной системе
счисления). При вводе чисел с плавающей запятой для отделения дробной части
используется точка, порядок числа отделяется буквой 'e' или 'E'. Например,
1.5e-3 - это 0.0015.
</p>

<p>В программе предопределены ряд констант. Так, '%i' означает комплексную
единицу, '%pi' - число "пи" (3.14..), '%e' - число Эйлера (2.71..).
Выражение
<code>
<table>
<tr>
  <th>pow(%e, %i*%pi)</th>
</tr>
</table>
</code>
вернёт <br>
<i>-1.000000-i*0.000000</i>  <br>
т.е. -1, что соответствует формуле Эйлера. Функция pow() могла быть заменена
на exp(%i*%pi), но использовалась для наглядности.
</p>

<p>Т.о. из чисел, функций, констант и переменных (см. далее) можно строить
математические выражения произвольной сложности и вычислять их значения. Только
не забывайте правильно группировать подвыражения с помощью скобок!
</p>

<a name="samp4"></a>
<h4>Пример 4. Переменные, константы, ссылки</h4>

<p>Вы можете создавать переменные и константы в процессе работы с программой.
Для этого запишите имя переменной после знака '%'. Например, строка
<code>
<table>
<tr>
  <th>%a = 0.1, %b</th>
</tr>
</table>
</code>
объявит 2 переменные, одна из которых будет инициализирована числом. Если
программа в дальнейшем встретит эту переменную, она заменит её на соответствующее
значение (если переменная не инициализирована, появится сообщение об ошибке).
Переменную можно в любой момент сделать константой, если записать перед ней
ключевое слово const. При попытке изменения константы также появится сообщение
об ошибке. Запись
<code>
<table>
<tr>
  <th>const %a, const %d = 1000</th>
</tr>
</table>
</code>
преобразует переменную %a в константу и объявляет новую константу %d. Если
результат не был присвоен какой-либо переменной, он заносится в переменную %ans.
</p>

<p>Все переменные и константы являются глобальными. Это важно помнить, в частности,
если вы загружаете скрипт, в котором имеются определения переменных. Чтобы
избежать путаницы, используйте разнообразные имена. В VPSYS на имена переменных
(и других структур данных) накладываются следующие ограничения: они могут быть
составлены из букв латинского алфавита, цифр и символа подчёркивания (_), при
этом не должны начинаться с цифры и быть длиннее 31 знака.
</p>

<p>Для доступа к данным, записанным в переменной, могут быть использованы ссылки.
Они записываются, как обычные переменные, но инициализируются с помощью знака
':='. Со ссылками можно работать как с обычными переменными, но важно иметь ввиду,
что все изменения будут касаться той переменной, на которую эта ссылка
распространяется.
<code>
<table>
<tr>
  <th>%x = 1, %y = %x, %z := %x</th>
  <th class="even"># %y - новая переменная, %z - ссылка</th>
</tr>
<tr>
  <th>%y = 2</th>
  <th class="even"># изменяется только %y</th>
</tr>
<tr>
  <th>%z = 3</th>
  <th class="even"># изменяется %x</th>
</tr>
<tr>
  <th>%x, %y, %z</th>
  <th class="even"># результат: 3 2 3</th>
</tr>
</table>
</code>
</p>

<p>В переменной может храниться любой из поддерживаемых типов данных (см. далее),
при этом способ представления в памяти задавать не нужно, программа сама его
определит. Если переменной присвоить новое значение, старое будет уничтожено. При
этом тип нового значения может отличаться от старого.

</p>

<a name="samp5"></a>
<h4>Пример 5. Массивы и строки</h4>

<p>В VPSYS используется 3 типа представления данных: числа, массивы чисел и
строки. Работа с числами обсуждалась в примере 3. Можно лишь добавить, что
логические значения также представляются в программе в виде чисел, при этом истине
соответствуют любые целые или вещественные числа, кроме 0. Далее рассмотрим 2
оставшихся типа данных.
</p>

<p>Строка - последовательность символов, заключённая в двойные кавычки. В VPSYS
строки служат, главным образом, для ввода текстовой информации. Единственная
доступная для них операция - конкатенация, которая обозначается знаком '+'. Если
первым слагаемым является строка, остальные слагаемые также будут представлены в
текстовом виде. Вот несколько примеров.
<code>
<table>
<tr>
  <th>"One," + "two"</th>
  <th class="even"># в %ans записывается "One,two"</th>
</tr>
<tr>
  <th>%s1 = "" + 1 + 2 + 3</th>
  <th class="even"># в %s1 записывается "123"</th>
</tr>
<tr>
  <th>%s2 = "" + (1 + 2 + 3)</th>
  <th class="even"># в %s2 записывается "6"</th>
</tr>
</table>
</code>
</p>

<p>Массив представляет собой упорядоченное множество элементов (в данном
случае - чисел), каждый из которых имеет свой индекс. По-умолчанию, число измерений
1, максимальное количество - 10. В настоящее время доступные для массивов операции
это изменение размера, инициализация и чтение/запись отдельных элементов. Они
демонстрируются на следующих примерах.
<code>
<table>
<tr>
  <th>%a1 = [1,2,3,4,5]</th>
  <th class="even"># при объявлении массива можно инициализировать
  его элементы перечислением</th>
</tr>
<tr>
  <th>%a1[0] + %a1[1]</th>
  <th class="even"># индексы также вводятся в квадратных скобках</th>
</tr>
<tr>
  <th>%a2 : [2,3]</th>
  <th class="even"># создан массив размером 2x3, элементы не заданы</th>
</tr>
<tr>
  <th>%a2 = [-1,-2,-3]</th>
  <th class="even"># элементы построчно заполняются, в оставшиеся
  записывается 0</th>
</tr>
<tr>
  <th>%a2[0,2]</th>
  <th class="even"># индексы многомерного массива перечисляются через запятую</th>
</tr>
<tr>
  <th>%a1 = 10</th>
  <th class="even"># все значения %a1 приравниваются 10</th>
</tr>
</table>
</code>
Следует добавить, что при изменении размеров массива его элементы не обнуляются.
Это позволяет преобразовать рамерность, например 4x1 в 2x2 без перезаписи значений.
Однако, если массив раньше не был объявлен, либо появились новые ячейки, их нужно
явно задать.
</p>

<h3>СОЗДАНИЕ СХЕМ</h3>

<a name="samp6"></a>
<h4>Пример 6. Первая схема</h4>

<p>Основное назначение VPSYS - моделирование поведения систем, состоящих из
заданных элементов. Перейдём к рассмотрению инструментов для решения данной
задачи.
</p>

<p>Для создания элемента заданного типа используется запись вида
<code>
<table>
<tr>
  <th>&ТИП имя_элемента</th>
</tr>
</table>
</code>
Если вы хотите добавить элементу какое-то описание, то можете сделать это следующим
образом
<code>
<table>
<tr>
  <th>&ТИП имя_элемента: "описание элемента"</th>
</tr>
</table>
</code>
</p>

<p>Каждый элемент характеризуется набором параметров в соответствии со своим типом.
Узнать список параметров и, если задано, их описание можно из имени типа:
<code>
<table>
<tr>
  <th>&ТИП ?</th>
</tr>
</table>
</code>
Установленные значения можно определить непосредственно из элемента:
<code>
<table>
<tr>
  <th>имя_элемента ?</th>
</tr>
</table>
</code>
Чтобы поменять значение параметра, воспользуйтесь следующей записью
<code>
<table>
<tr>
  <th>&ТИП имя_элемента: параметр1=значение1, параметр2=значение2</th>
  <th class="even"># при создании элемента</th>
</tr>
<tr>
  <th>имя_элемента: параметр1=значение3, параметр2=значение4</th>
  <th class="even"># если элемент уже создан</th>
</tr>
</table>
</code>
Если параметров много, можно разбить инициализацию на несколько строк, но при
этом каждая строка, кроме последней, должна заканчиваться запятой.
</p>

<p>Помимо параметров каждый элемент характеризуется определённым набором входов
и выходов ("коннекторов"). Для формирования схемы нужно соединить коннекторы
соответствующих элементов с помощью "стрелки":
<code>
<table>
<tr>
  <th>элемент1'выход' -> 'вход'элемент2</th>
</tr>
</table>
</code>
Имя коннектора записывается в одинарных кавычках. Если элемент имеет один вход/выход,
или вы хотите использовать первый из списка, имя коннектора можно опустить.
<code>
<table>
<tr>
  <th>элемент1 -> элемент2</th>
</tr>
</table>
</code>
Также допускается записывать последовательности передачи данных в виде "цепочек":
<code>
<table>
<tr>
  <th>элемент1 -> 'вхN'элемент2'выхM' -> 'вхK'элемент3</th>
  <th class="even"># элемент1 -> 'вхN'элемент2, элемент2'выхM' ->
  'вхK'элемент3</th>
</tr>
</table>
</code>
Получить справочную информацию для коннекторов можно так же, как для параметров.
</p>

<p>Перейдём непосредственно к созданию схемы. Она будет выводить на экран
точки синусоиды. Данная схема состоит из 2-х элементов: первый - источник, формирующий
синусоидальный сигнал от времени, второй - приёмник, передающий результат в
текстовом виде в поток вывода (в данном случае, на терминал). Вот код:
<code>
<table>
<tr>
  <th>&SRC a: func = "sin"</th>
  <th class="even"># источник - генератор синусоидального сигнала</th>
</tr>
<tr>
  <th>&SYNC b</th>
  <th class="even"># приёмник представляет данные в текстовом виде</th>
</tr>
<tr>
  <th>a -> b</th>
  <th class="even"># т.к. число входов и выходов 1, используем упрощённую запись</th>
</tr>
<tr>
  <th>Run 0...%pi, 0.05</th>
  <th class="even"># вычисление на интервале от 0 до 3.14 с шагом 0.05</th>
</tr>
</table>
</code>
Последняя строка - это команда на исполнение. При этом на основе установленных
связей (стрелок) формируется последовательность обработки элементов, а затем для
указанного интервала времени запускается цикл исполнения.
</p>

<p>Команда run может быть записана без дополнительных параметров. В этом случае
расчёт будет произведён однократно для начального времени, установленного
по-умолчанию (0). Чтобы его поменять, присвойте новое значение переменной %tau0.
Если вы хотите провести расчёт при изменении времени с определённым шагом, запишите
это так, как указано в примере. Если опустить начальное время или величину шага
(записана после запятой), также будут использованы значения по-умолчанию. Т.о. в
данном примере можно было записать
<code>
<table>
<tr>
  <th>Run %pi, 0.05</th>
</tr>
</table>
</code>
либо
<code>
<table>
<tr>
  <th>Run %pi</th>
  <th class="even"># начальное время и шаг заданы по-умолчанию</th>
</tr>
</table>
</code>
</p>

<a name="samp7"></a>
<h4>Пример 7. Вторая схема</h4>

<p>В следующем примере показаны ещё некоторые возможности, полезные при составлении
схем. Здесь использованы несколько источников и приёмников, результат одновременно
выводится на экран и записывается в файл.
<code>
<table>
<tr>
  <th>&SRC a: func = "sin", k = 10</th>
  <th class="even"># источник - генератор синусоидального сигнала</th>
</tr>
<tr>
  <th>&& b = a</th>
  <th class="even"># элемент b - создан как копия a благодаря команде &&</th>
</tr>
<tr>
  <th>b: k = 0.5</th>
  <th class="even"># уменьшаем частоту </th>
</tr>
<tr>
  <th>&SYNC c, d</th>
  <th class="even"># элементы одинаковых типов можно создавать в одной строке</th>
</tr>
<tr>
  <th>d: fname = "sin_summ.dat"</th>
  <th class="even"># если задано имя, результат записывается в файл</th>
</tr>
<tr>
  <th>&SUM s</th>
  <th class="even"># сумматор </th>
</tr>
<tr>
  <th>a -> s -> c, b -> s -> d</th>
  <th class="even"># s суммирует сигналы a и b и выводит в c и d</th>
</tr>
<tr>
  <th>Run %pi, 0.01</th>
  <th class="even"># расчёт </th>
</tr>
</table>
</code>
Несмотря на указанный шаг 0.01, результат будет выведен с шагом 0.1, т.к. данная
величина прописана в параметре scale элемента sync по-умолчанию.
</p>

<p>В завершение рассмотрим возможность применения переменных и ссылок. Следующий
пример демонстрирует, как ещё можно было задать параметры элемента a.
<code>
<table>
<tr>
  <th>%str = "sin"</th>
  <th class="even"># вид функции сохраняем в строковой переменной </th>
</tr>
<tr>
  <th>&SRC a: func = %str, %pk = k</th>
  <th class="even"># создаём ссылку pk на параметр k</th>
</tr>
<tr>
  <th>%pk = 10</th>
  <th class="even"># устанавливаем значение с помощью ссылки</th>
</tr>
</table>
</code>
</p>

<a name="samp8"></a>
<h4>Пример 8. Свёртки</h4>

<p>Свёрткой в данной программе названа передача создания некоторых элементов
интерпретатору для упрощения формирования схемы. Свётка формируется на этапе
связывания элементов и вызывается с помощью выражения, заключённого в квадратные
скобки. Чтобы стало понятно, о чём идёт речь, рассмотрим 2 фрагмента кода,
эквивалентных с точки зрения результата. В первом случае все элементы создаются
пользователем.
<code>
<table>
<tr>
  <th>&SRC a: func = "lin"</th>
  <th class="even"># генератор линейного сигнала </th>
</tr>
<tr>
  <th>&OP b: op = "*", k = 2</th>
  <th class="even"># умножаем входной сигнал на 2</th>
</tr>
<tr>
  <th>&FUNC c: f = "sqrt"</th>
  <th class="even"># вычисляем квадратный корень</th>
</tr>
<tr>
  <th>&SYNC d</th>
  <th class="even"># выводим результат</th>
</tr>
<tr>
  <th>a -> b -> c -> d</th>
  <th class="even"># формируем цепочку</th>
</tr>
</table>
</code>
Во втором варианте используется свёртка.
<code>
<table>
<tr>
  <th>&SRC a: func = "lin"</th>
  <th class="even"># генератор линейного сигнала </th>
</tr>
<tr>
  <th>&SYNC d</th>
  <th class="even"># выводим результат</th>
</tr>
<tr>
  <th>a -> [*2][sqrt] d</th>
  <th class="even"># формируем цепочку с применением свёртки</th>
</tr>
</table>
</code>
Результат получится тот же, но часть действий программа взяла на себя, мы лишь
объяснили ей, что хотим сделать. Т.о. свёртка может быть использована для того,
чтобы добавить некоторое простое преобразование данных между 2-мя элементами.
</p>

<a name="samp9"></a>
<h4>Пример 9. Графы и блоки</h4>

<p>Все создаваемые элементы логически объединяются в блоки, условно называемые
графами. Внутри графа каждый элемент должен иметь уникальное имя. Такие действия,
как поиск элемента или команда Run относятся к текущему графу. Узнать его имя
можно с помощью команды
<code>
<table>
<tr>
  <th>@ ?</th>
  <th class="even"># узнать текущий граф</th>
</tr>
</table>
</code>
а описание (если есть) и список элементов отображаются при команде
<code>
<table>
<tr>
  <th>@ИМЯ ?</th>
  <th class="even"># ИМЯ - название графа</th>
</tr>
</table>
</code>
Чтобы создать новый граф и/или перейти в него, просто укажите имя после знака '@'.
<code>
<table>
<tr>
  <th>@ИМЯ </th>
</tr>
</table>
</code>
Сослаться на элемент другого графа (при изменении значения параметра или установке
связи) можно в виде ЭЛЕМЕНТ@ГРАФ, например
<code>
<table>
<tr>
  <th>elt1 -> elt2@grB</th>
  <th class="even"># данные элемента текущего графа направляются в @grB</th>
</tr>
</table>
</code>
</p>

<p>Использование графов позволяет разделять рабочее пространство на отдельные
зоны, например, при работе с несколькими схемами. Другое применение графов
заключается в объединении связанных или не связанных элементов в функциональные
группы для использования в составе других схем. Такая функциональная группа может
быть преобразована в "блок", т.е. элемент, содержащий в себе другие элементы.
Следующий фрагмент кода сформирует генератор сигнала по закону квадратного корня от
времени.
<code>
<table>
<tr>
  <th>@SQRT</th>
  <th class="even"># создаём новый граф и переходим в него </th>
</tr>
<tr>
  <th>&SRC a: func = "lin"</th>
  <th class="even"># генератор линейного сигнала </th>
</tr>
<tr>
  <th>&FUNC b: f = "sqrt"</th>
  <th class="even"># квадратный корень</th>
</tr>
<tr>
  <th>a -> b</th>
  <th class="even"># формируем цепочку</th>
</tr>
<tr>
  <th>@BASE</th>
  <th class="even"># возвращаемся в основной граф </th>
</tr>
<tr>
  <th>@SQRT srcSqrt</th>
  <th class="even"># создаём блок srcSqrt </th>
</tr>
<tr>
  <th>@SYNC b</th>
  <th class="even"># вывод данных, имя b в данном графе не занято</th>
</tr>
<tr>
  <th>srcSqrt -> b</th>
  <th class="even"># используем блок как обычный элемент </th>
</tr>
</table>
</code>
Про последнюю строку следует добавить, что при формировании блока все не связанные
с внутренними элементами коннекторы автоматически дублируются для данного блока.
Т.к. выход b@sqrt не был подключён к другим элементам графа @sqrt, он был "выведен"
из блока. Других выводов, в данном случае, не было, по-этому мы и смогли
использовать приведённую выше запись.
</p>

<p>Обратиться к элементу в составе блока можно в формате БЛОК.ЭЛЕМЕНТ. Если элемент
в свою очередь тоже является блоком, цепочка может быть продолжена:
БЛОК2.БЛОК1.ЭЛЕМЕНТ и т.д. Например, запись
<code>
<table>
<tr>
  <th>srcSqrt.b: func = "ln" </th>
  <th class="even"># доступ к элементам блока</th>
</tr>
</table>
</code>
превращает наш источник в генератор логарифмического сигнала. Тем же путём можно
вывести сигнал с элемента, коннектор которого не был автоматически продублирован
в блоке.
</p>

<a name="samp10"></a>
<h4>Пример 10. Дифференциальное уравнение</h4>

<p>Попробуем применить VPSYS на практике, а именно, для решения простого
дифференциального уравнения. Возьмём уравнение колебаний математического маятника:
<br><i> y'' = -(w0)<sup>2</sup> * y(t) </i><br>
Нам нужно найти зависимость y(t). С одной стороны, чтобы её получить, нужно
дважды проинтегрировать y'', с другой - мы видим, что вторая производная получается
из искомой зависимости простым умножением на заданную величину. Т.о. решение можно
построить в виде замкнутой последовательности <br>
<i>y'' -> интеграл - скорость (y') -> интеграл - угол (y) -> |* -w0<sup>2</sup> | -> y'' </i><br>
Попробуем это реализовать в программе.
<code>
<table>
<tr>
  <th>&XINT speed, angle</th>
  <th class="even"># интегралы </th>
</tr>
<tr>
  <th>angle: x0 = %pi/6</th>
  <th class="even"># начальное значение второго интеграла (угол) </th>
</tr>
<tr>
  <th>&SYNC y</th>
  <th class="even"># вывод результата </th>
</tr>
<tr>
  <th>%w0 = 2</th>
  <th class="even"># коэффициент (частота) </th>
</tr>
<tr>
  <th>speed -> angle -> y, angle -> [*(-%w0*%w0)]speed</th>
  <th class="even"># строим схему </th>
</tr>
<tr>
  <th>Run 5, 0.01</th>
  <th class="even"># наблюдение в течение 5 с </th>
</tr>
</table>
</code>
Поскольку данное уравнение описывает гармоническое колебание, на выходе должна
получиться синусоида с периодом 2*%pi/%w0.
</p>

<a name="samp11"></a>
<h4>Пример 11. Создание нового типа</h4>

<p>VPSYS задумывался, прежде всего, как платформа для моделирования систем, и
ключевую роль здесь играет возможность построения на базе готовых типовых элементов.
Конечно, трудно представить все возможные варианты, которые могут понадобиться,
по-этому в программу закладывалась возможность для пользователя самостоятельно
добавлять то, что ему необходимо. В настоящий момент существует 2 пути достижения
данной цели: написание кода на C/C++, либо использование встроенного скриптового
языка. В дальнейшем предполагается поддержка Lua и, возможно, других инструментов.
</p>

<p>В этом примере рассмотрим создание нового типа на основе встроенного языка
сценариев. В настоящий момент он предоставляет ограниченный набор возможностей, в
частности, работа возможно только с числами (но не массивами). Некоторые функции
будут в дальнейшем добавлены, однако для решения сложных задач предполагается
подключение более мощных инструментов. Тем не менее, преимуществом строенного
скриптового языка может являться то, что он транслируется в байт-код, что позволит
несколько ускорить обработку данных.
</p>

<p>Описание типа должно быть сохранено в файле с расширением ".t" и расположено в
той же директории, где находится сама программа. Имя файла и типа совпадают. Если в
первой строке содержится строковая переменная, она будет сохранена как описание
типа. Затем должны находиться разделы, в которых определяются коннекторы и параметры,
их взаимное размещение роли не играет. Каждый раздел начинается с оператора
"многоточия", за которым следует наименование раздела: IN - входные коннекторы,
OUT - выходные коннекторы, PAR - параметры. Далее определяется список
коннекторов/параметров, при необходимости, устанавливаются их характеристики.
Затем строкой "... FUNC" вводится функция для обработки. Она может содержать объявления,
присваивания, условный переход IF - THEN - ELSE - END и цикл WHILE - DO - END.
Для примера опишем тип, который генерирует меандр с заданной амплитудой и частотой.
</p>

<p><code>
# meandr.t    <br>
"Meandr generator" # type description <br>
... PAR <br>
# parameters <br>
amp, t # define amplitude and period    <br>
amp: "meandr amplitude" # description <br>
amp: val = 1 # default amplitude  <br>
t: val = %pi # default period <br>
... OUT <br>
# output connectors  <br>
out0: type = number # output for single number (default) <br>
... FUNC    <br>
# data processing   <br>
# use sinusoid and 'tau' - time variable <br>
k = 2*%pi/t #  internal variable  <br>
IF sin(k * tau) > 0 THEN     <br>
out0 = amp <br>
ELSE <br>
out0 = 0 <br>
END
</code></p>

<p>Чтобы добавить определённый выше тип, достаточно указать его имя, и затем
можно пользоваться им как прочими встроенными типами.
<code>
<table>
<tr>
  <th>&MEANDR a: t = %pi/4</th>
  <th class="even"># если файл meandr.t найден и успешно интерпретирован, проблем
  не возникнет </th>
</tr>
<tr>
  <th>&SYNC b</th>
  <th class="even"># вывод результата </th>
</tr>
<tr>
  <th>a -> b</th>
  <th class="even"># линковка </th>
</tr>
<tr>
  <th>Run %pi, 0.1</th>
  <th class="even"># запуск </th>
</tr>
</table>
</code>
</p>

<center><small>Станислав Михель :
<a href="mailto:vpsys@yandex.ru">vpsys@yandex.ru</a></small></center>

</body>
</html>